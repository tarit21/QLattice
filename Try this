# app.py — Full-featured Hackathon-ready Manufacturing Inventory Copilot
import streamlit as st
import pandas as pd
import numpy as np
import altair as alt
from datetime import datetime, timedelta
from typing import Tuple
from langchain_openai import ChatOpenAI
import httpx
import json
import io

# -------------------------
# CONFIG
# -------------------------
EXCEL_FILE = "manufacturing_data.xlsx"
BASE_URL = "https://genailab.tcs.in/"
MODEL = "azure_ai/genailab-maas-DeepSeek-V3-0324"
DEEPSEEK_API_KEY = st.secrets.get("DEEPSEEK_API_KEY", "sk-xxx")  # Put real key in secrets for demo

st.set_page_config(page_title="Manufacturing Inventory Copilot", layout="wide")

# -------------------------
# UTIL / LOAD
# -------------------------
@st.cache_data
def load_all(file: str) -> dict:
    xls = pd.ExcelFile(file)
    sheets = {s: pd.read_excel(xls, s) for s in xls.sheet_names}
    # Normalize column names to lower for consistent code, but keep originals too
    normalized = {}
    for k, df in sheets.items():
        new_df = df.copy()
        new_df.columns = [c.strip() for c in new_df.columns]
        normalized[k] = new_df
    return normalized

data = None
try:
    data = load_all(EXCEL_FILE)
except Exception as e:
    st.error(f"Failed to load {EXCEL_FILE}: {e}")
    st.stop()

# Required sheets check
required = ["Inventory", "Usage", "Suppliers"]
missing = [r for r in required if r not in data]
if missing:
    st.error(f"Missing required sheets: {', '.join(missing)}")
    st.stop()

# assign dataframes
inv_df = data["Inventory"].copy()
usage_df = data["Usage"].copy()
sup_df = data["Suppliers"].copy()
po_df = data.get("PurchaseOrders", pd.DataFrame()).copy()
bom_df = data.get("BOM", pd.DataFrame()).copy()
sched_df = data.get("Schedule", pd.DataFrame()).copy()

# Ensure date types
if "date" in usage_df.columns:
    usage_df["date"] = pd.to_datetime(usage_df["date"])
else:
    # try common variations
    for c in usage_df.columns:
        if "date" in c.lower():
            usage_df = usage_df.rename(columns={c: "date"})
            usage_df["date"] = pd.to_datetime(usage_df["date"])
            break

# -------------------------
# PREDICTIVE FUNCTIONS
# -------------------------
@st.cache_data
def compute_avg_daily_usage(usage: pd.DataFrame, lookback_days: int = 30) -> pd.DataFrame:
    if usage.empty:
        return pd.DataFrame(columns=["part_id", "avg_daily_usage"])
    max_date = usage["date"].max()
    start_date = max_date - pd.Timedelta(days=lookback_days)
    recent = usage[usage["date"] > start_date]
    if recent.empty:  # fallback to overall average
        grouped = usage.groupby("part_id")["demand_qty"].mean().reset_index()
        grouped = grouped.rename(columns={"demand_qty": "avg_daily_usage"})
        return grouped
    # compute average daily demand per part over lookback period
    daily = recent.groupby(["part_id", "date"])["demand_qty"].sum().reset_index()
    avg_daily = daily.groupby("part_id")["demand_qty"].mean().reset_index().rename(columns={"demand_qty": "avg_daily_usage"})
    return avg_daily

def days_to_stockout(inv: pd.DataFrame, avg_usage: pd.DataFrame) -> pd.DataFrame:
    merged = inv.merge(avg_usage, on="part_id", how="left").fillna({"avg_daily_usage": 0})
    # prevent division by zero
    merged["days_to_stockout"] = np.where(merged["avg_daily_usage"] > 0, merged["on_hand"] / merged["avg_daily_usage"], np.inf)
    merged["expected_stockout_date"] = pd.to_datetime("today") + pd.to_timedelta(np.ceil(merged["days_to_stockout"]), unit="D")
    merged.loc[np.isinf(merged["days_to_stockout"]), "expected_stockout_date"] = pd.NaT
    return merged

def forecast_next_n_days_usage(avg_daily: pd.DataFrame, n: int) -> pd.DataFrame:
    fc = avg_daily.copy()
    fc[f"expected_demand_{n}d"] = (fc["avg_daily_usage"] * n).round(2)
    return fc[["part_id", f"expected_demand_{n}d"]]

def compute_restock(inv: pd.DataFrame, avg_daily: pd.DataFrame, suppliers: pd.DataFrame, days: int = 30, safety_days: int = 3) -> pd.DataFrame:
    """Recommend reorder quantities to cover next `days` plus safety_days."""
    forecast = forecast_next_n_days_usage(avg_daily, days + safety_days).rename(columns={f"expected_demand_{days + safety_days}d": "expected_demand_ndays"})
    merged = inv.merge(forecast, on="part_id", how="left").fillna({"expected_demand_ndays": 0})
    merged["gap"] = (merged["expected_demand_ndays"] - merged["on_hand"]).clip(lower=0)
    # recommended = max(gap, MOQ) if gap > 0
    merged["recommended_order_qty"] = np.where(merged["gap"] > 0, np.maximum(merged["gap"].round().astype(int), merged["MOQ"].fillna(0).astype(int)), 0)
    merged = merged.merge(suppliers, on="supplier_id", how="left")
    # priority score: higher expected demand, lower on_hand, higher lead_time, lower rating => higher urgency
    merged["priority_score"] = ((merged["expected_demand_ndays"] / (merged["on_hand"] + 1)) * (merged["lead_time_days"] + 1) * (5 - merged["rating"].fillna(3))).round(3)
    reco = merged[merged["recommended_order_qty"] > 0].copy()
    reorder_cols = ["part_id", "description", "category", "on_hand", "reorder_point", "expected_demand_ndays", "MOQ", "recommended_order_qty", "supplier_id", "name", "lead_time_days", "rating", "priority_score"]
    # keep only available columns
    reorder_cols = [c for c in reorder_cols if c in reco.columns]
    return reco[reorder_cols].sort_values(["priority_score", "lead_time_days"], ascending=[False, True])

# -------------------------
# BOM & production-driven demand
# -------------------------
@st.cache_data
def production_demand(schedule: pd.DataFrame, bom: pd.DataFrame) -> pd.DataFrame:
    if schedule.empty or bom.empty:
        return pd.DataFrame(columns=["part_id", "projected_demand"])
    merged = schedule.merge(bom, on="car_model", how="left")
    merged["part_demand"] = merged["planned_qty"] * merged["qty_per_car"]
    proj = merged.groupby("part_id")["part_demand"].sum().reset_index().rename(columns={"part_demand": "projected_demand"})
    return proj

# -------------------------
# LLM (LangChain ChatOpenAI) setup
# -------------------------
def build_llm_client():
    if not DEEPSEEK_API_KEY or DEEPSEEK_API_KEY.startswith("sk-xxx"):
        return None, "⚠️ Set DEEPSEEK_API_KEY in Streamlit secrets before using LLM features."
    client = httpx.Client(verify=False)
    llm = ChatOpenAI(base_url=BASE_URL, model=MODEL, api_key=DEEPSEEK_API_KEY, http_client=client)
    return llm, None

def df_to_json_for_prompt(df: pd.DataFrame, name: str, max_rows: int = 60) -> str:
    if df is None or df.empty:
        return f'"{name}": []'
    j = df.head(max_rows).to_dict(orient="records")
    return f'"{name}": {json.dumps(j, default=str)}'

def ask_llm_grounded(llm_client, question: str, context_frames: dict) -> str:
    # Build JSON-ish context string of chosen frames
    parts = [df_to_json_for_prompt(df, name) for name, df in context_frames.items()]
    context_text = "{\n" + ",\n".join(parts) + "\n}"
    messages = [
        {"role": "system", "content": "You are a manufacturing inventory assistant. Answer ONLY using the provided JSON context. If not present, say you don't have enough data."},
        {"role": "user", "content": f"Context JSON:\n{context_text}"},
        {"role": "user", "content": f"Question:\n{question}"}
    ]
    resp = llm_client.invoke(messages)
    return resp.content

# -------------------------
# COMPUTE PREDICTIVE METRICS
# -------------------------
avg_daily_usage = compute_avg_daily_usage(usage_df, lookback_days=30)  # col part_id, avg_daily_usage
stockout_df = days_to_stockout(inv_df, avg_daily_usage)
forecast_30 = forecast_next_n_days_usage(avg_daily_usage, 30)
restock_df = compute_restock(inv_df, avg_daily_usage, sup_df, days=30, safety_days=3)
prod_demand = production_demand(sched_df, bom_df)

# -------------------------
# UI — Header & quick metrics
# -------------------------
st.title("🏭 Manufacturing Inventory Copilot — Predictive & Actionable")
st.markdown("**One-stop demo**: Inventory visibility, predictive stockout, prioritized restock, supplier insights, BOM-driven demand, scenario simulation, and grounded LLM explanations.")

c1, c2, c3, c4 = st.columns(4)
c1.metric("Parts", f"{len(inv_df):,}")
c2.metric("Suppliers", f"{len(sup_df):,}")
c3.metric("Low stock (on_hand < reorder_point)", f"{len(inv_df[inv_df['on_hand'] < inv_df['reorder_point']]):,}")
c4.metric("At-risk (7d forecast)", f"{(stockout_df['days_to_stockout'] <= 7).sum():,}")

# Proactive alert banner
num_at_risk_7 = int((stockout_df["days_to_stockout"] <= 7).sum())
if num_at_risk_7 > 15:
    st.error(f"🚨 High risk: {num_at_risk_7} parts projected to run out in 7 days!")
elif num_at_risk_7 > 0:
    st.warning(f"⚠️ {num_at_risk_7} parts projected to run out in 7 days.")
else:
    st.success("✅ No parts projected to stock out within 7 days.")

# -------------------------
# Tabs (Dashboard, Predictive, Suppliers, BOM, LLM)
# -------------------------
tab1, tab2, tab3, tab4, tab5 = st.tabs(["📦 Inventory", "🔮 Predictive & Restock", "📊 Supplier Insights", "🧩 BOM & Production", "🤖 Copilot (LLM)"])

# --- Inventory tab
with tab1:
    st.header("Current Inventory")
    st.dataframe(inv_df, use_container_width=True)
    st.subheader("Recent Purchase Orders")
    if not po_df.empty:
        st.dataframe(po_df.sort_values(by=po_df.columns[0]).tail(20), use_container_width=True)
    else:
        st.info("No purchase orders sheet present.")

# --- Predictive & Restock tab
with tab2:
    st.header("Predictive Stock & Restock Recommendations")
    st.subheader("Average Daily Usage (last 30 days)")
    st.dataframe(avg_daily_usage.head(50), use_container_width=True)

    st.subheader("Stockout Projection (days to stockout & expected date)")
    display_stockout = stockout_df[["part_id", "description", "on_hand", "avg_daily_usage", "days_to_stockout", "expected_stockout_date"]].copy()
    display_stockout["days_to_stockout"] = display_stockout["days_to_stockout"].replace(np.inf, np.nan)
    st.dataframe(display_stockout.sort_values("days_to_stockout").head(100), use_container_width=True)

    st.subheader("Recommended Restock to cover next 30d (+3d safety)")
    if restock_df.empty:
        st.success("No restock recommended based on forecast.")
    else:
        st.dataframe(restock_df, use_container_width=True)
        csv = restock_df.to_csv(index=False)
        st.download_button("📥 Download Restock Plan CSV", csv, file_name="restock_plan.csv")

    st.subheader("Priority visualization")
    if not restock_df.empty and "lead_time_days" in restock_df.columns and "rating" in restock_df.columns:
        chart = alt.Chart(restock_df).mark_circle(size=90).encode(
            x="lead_time_days",
            y="priority_score",
            color="category",
            tooltip=["part_id", "description", "recommended_order_qty", "supplier_id", "name", "lead_time_days", "rating"]
        ).interactive()
        st.altair_chart(chart, use_container_width=True)

    st.subheader("One-click actions (judge demo)")
    c1, c2 = st.columns(2)
    if c1.button("Show top 10 urgent orders"):
        st.dataframe(restock_df.head(10), use_container_width=True)
    if c2.button("Show items running out in <7 days"):
        st.dataframe(display_stockout[display_stockout["days_to_stockout"] <= 7].sort_values("days_to_stockout").head(50), use_container_width=True)

# --- Supplier Insights tab
with tab3:
    st.header("Suppliers & Performance")
    st.dataframe(sup_df, use_container_width=True)
    st.subheader("Lead Time vs Rating")
    if not sup_df.empty:
        chart = alt.Chart(sup_df).mark_circle(size=120).encode(
            x="lead_time_days",
            y="rating",
            tooltip=["supplier_id", "name", "lead_time_days", "rating"]
        ).interactive()
        st.altair_chart(chart, use_container_width=True)

    st.subheader("Supplier Concentration Risk (Top suppliers by critical parts)")
    # supplier concentration: count of critical parts from restock_df
    if not restock_df.empty:
        sc = restock_df.groupby(["supplier_id", "name"])["part_id"].nunique().reset_index(name="critical_part_count").sort_values("critical_part_count", ascending=False)
        st.dataframe(sc.head(20), use_container_width=True)
    else:
        st.info("No critical parts identified.")

# --- BOM & Production tab
with tab4:
    st.header("BOM-driven Demand & Production Impact")
    if not bom_df.empty and not sched_df.empty:
        st.subheader("Projected Demand from current production schedule")
        pdemand = prod_demand.reset_index() if "projected_demand" in prod_demand.columns else prod_demand
        st.dataframe(pdemand.head(200), use_container_width=True)
        st.subheader("Top bottlenecks if schedule runs")
        merged_bottlenecks = pdemand.merge(inv_df, on="part_id", how="left")
        merged_bottlenecks["shortfall"] = (merged_bottlenecks["projected_demand"] - merged_bottlenecks["on_hand"]).clip(lower=0)
        st.dataframe(merged_bottlenecks.sort_values("shortfall", ascending=False).head(30), use_container_width=True)
    else:
        st.info("BOM or Schedule sheet not present — generator may not have produced those.")

    st.subheader("Scenario Simulator")
    surge_pct = st.slider("Demand Surge %", 0, 200, 20)
    if st.button("Simulate surge impact"):
        # apply surge and recompute stockouts
        surged = avg_daily_usage.copy()
        surged["avg_daily_usage"] = surged["avg_daily_usage"] * (1 + surge_pct/100)
        simulated = days_to_stockout(inv_df, surged)
        sim_at_risk = simulated[simulated["days_to_stockout"] <= 7]
        st.write(f"Parts at risk within 7 days under {surge_pct}% surge: {len(sim_at_risk)}")
        st.dataframe(sim_at_risk[["part_id", "description", "on_hand", "avg_daily_usage", "days_to_stockout"]].sort_values("days_to_stockout").head(100), use_container_width=True)

# --- Copilot / LLM tab
with tab5:
    st.header("Copilot — Ask the LLM (grounded in your data)")
    llm, err = build_llm_client()
    if err:
        st.warning(err)
        st.info("LLM disabled until API key set in secrets.")
    st.caption("Choose which tables to include in the LLM context (smaller selections = cheaper + faster).")
    ctx_options = st.multiselect("Include context:",
                                 options=["Inventory (sample)", "Low Stock", "Predicted Stockouts (7d)", "Restock Recommendations (30d)", "Recent Purchase Orders (20)", "Production Demand"],
                                 default=["Inventory (sample)", "Low Stock", "Restock Recommendations (30d)"])

    # Build chosen context frames
    ctx = {}
    if "Inventory (sample)" in ctx_options:
        ctx["Inventory"] = inv_df.head(60)
    if "Low Stock" in ctx_options:
        ctx["LowStock"] = inv_df[inv_df["on_hand"] < inv_df["reorder_point"]]
    if "Predicted Stockouts (7d)" in ctx_options:
        ctx["Stockouts7d"] = stockout_df[stockout_df["days_to_stockout"] <= 7]
    if "Restock Recommendations (30d)" in ctx_options:
        ctx["Restock30d"] = restock_df
    if "Recent Purchase Orders (20)" in ctx_options and not po_df.empty:
        ctx["RecentPOs"] = po_df.sort_values(by=po_df.columns[0]).tail(20)
    if "Production Demand" in ctx_options:
        ctx["ProductionDemand"] = prod_demand

    # cheat sheet & quick prompts
    st.subheader("Demo Quick Prompts")
    cheat = [
        "List parts projected to stock out in the next 7 days and expected dates.",
        "Give a prioritized restock plan for the next 30 days with supplier and lead time.",
        "Which suppliers are critical and what is the concentration risk?",
        "If demand increases by 20%, which parts will be most impacted?"
    ]
    cols = st.columns(2)
    for i, q in enumerate(cheat):
        with cols[i % 2]:
            if st.button(q):
                if llm is None:
                    st.error("LLM not configured.")
                else:
                    try:
                        ans = ask_llm_grounded(llm, q, ctx)
                        st.info(ans)
                    except Exception as e:
                        st.error(f"LLM error: {e}")

    st.subheader("Ask a custom question")
    user_q = st.text_area("Type your question (be specific):", height=120)
    if st.button("Ask Copilot"):
        if llm is None:
            st.error("LLM not configured.")
        elif not user_q.strip():
            st.warning("Type a question first.")
        else:
            try:
                ans = ask_llm_grounded(llm, user_q, ctx)
                st.success(ans)
            except Exception as e:
                st.error(f"LLM error: {e}")

    with st.expander("Show context preview (JSON-ish)"):
        for k, df in ctx.items():
            st.write(f"### {k} (first rows)")
            st.dataframe(df.head(10))

# -------------------------
# Footer: demo script & tips
# -------------------------
st.markdown("---")
st.markdown("## Demo Script & Judge Tips")
st.markdown("""
**Demo Flow (1-2 minutes):**
1. Open **Predictive & Restock** tab → show `Recommended Restock`.  
2. Click **Show items running out in <7 days** → explain urgency and ordering.  
3. Open **Supplier Insights** → show concentration & lead-time scatter chart.  
4. Open **BOM & Production** → show bottlenecks for scheduled production.  
5. Open **Copilot** → run quick prompt: *'Give a prioritized restock plan for the next 30 days...'*.  
6. Download restock CSV and show it's production-ready.

**Key selling points:**
- Predictive: days-to-stockout & expected date from real usage.  
- Actionable: recommended order qty (covers forecast + safety) and prioritized by supplier lead time & rating.  
- Explainable: LLM grounded in the same data you show judges — no hallucination.  
- Scenario-ready: what-if surge & BOM-driven demand integrated.

Want me to:
- Minify or annotate the code for your slides?  
- Generate a 1-minute spoken demo script you can memorize?  
- Add company/team branding (logo + colors)?
""")
